"""
Streamlit application providing an interactive view of strategic alpha analytics.
"""

from __future__ import annotations

from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Any, Dict, Iterable, List, Tuple

import pandas as pd
import streamlit as st
import yfinance as yf

from app.components.charts import dcf_heatmap, macro_chart, price_chart, risk_histogram
from app.components.kpi_cards import render_kpi_cards
from app.components.tables import format_chokepoints, format_comps
from src import macro, risk, supply, valuation
from src.config import ROOT_DIR, get_settings


def _format_dollar(value: float | None) -> str:
    if value is None or pd.isna(value):
        return "NA"
    if abs(value) >= 1_000_000_000:
        return f"${value/1_000_000_000:.1f}B"
    if abs(value) >= 1_000_000:
        return f"${value/1_000_000:.1f}M"
    return f"${value:,.0f}"


def _fetch_quote_info(ticker: str) -> Dict[str, float | str]:
    """Safely request ticker fundamentals from yfinance."""
    try:
        info = yf.Ticker(ticker).info or {}
    except Exception:  # pragma: no cover - defensive
        info = {}
    return info


def _last_12m(prices: pd.Series) -> pd.Series:
    if prices.empty:
        return prices
    cutoff = prices.index.max() - pd.DateOffset(months=12)
    return prices[prices.index >= cutoff]


def _dcf_override_inputs(base_inputs: Any) -> Dict[str, float]:
    col1, col2, col3 = st.columns(3)
    col4, col5, col6 = st.columns(3)

    revenue_growth = col1.number_input(
        "Revenue Growth %",
        value=base_inputs.revenue_growth * 100,
        format="%.2f",
    )
    ebit_margin = col2.number_input(
        "EBIT Margin %",
        value=base_inputs.ebit_margin * 100,
        format="%.2f",
    )
    tax_rate = col3.number_input(
        "Tax Rate %",
        value=base_inputs.tax_rate * 100,
        format="%.2f",
    )
    reinvestment = col4.number_input(
        "Reinvestment Rate %",
        value=base_inputs.reinvestment_rate * 100,
        format="%.2f",
    )
    wacc = col5.number_input(
        "WACC %",
        value=base_inputs.wacc * 100,
        format="%.2f",
    )
    terminal_growth = col6.number_input(
        "Terminal Growth %",
        value=base_inputs.terminal_growth * 100,
        format="%.2f",
    )

    return {
        "revenue_growth": revenue_growth / 100,
        "ebit_margin": ebit_margin / 100,
        "tax_rate": tax_rate / 100,
        "reinvestment_rate": reinvestment / 100,
        "wacc": wacc / 100,
        "terminal_growth": terminal_growth / 100,
    }


def _report_content(
    ticker: str,
    macro_result: Any,
    supply_df: pd.DataFrame,
    dcf_result: Dict[str, Any],
    comps_table: pd.DataFrame,
    risk_summary: Dict[str, Dict[str, float]],
    dcf_overrides: Dict[str, float],
    peers: Iterable[str],
) -> str:
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    metrics = macro_result.metrics
    historical = risk_summary["historical"]
    variance_covariance = risk_summary["variance_covariance"]
    stress = risk_summary["stress"]

    overrides_text = "\n".join(
        f"- {key.replace('_', ' ').title()}: {value * 100:.2f}%"
        for key, value in dcf_overrides.items()
    )

    report = f"""# {ticker.upper()} Dashboard Memo

Generated: {timestamp}

## Macro Context
- CPI YoY: {metrics['cpi_yoy']:.2f}%
- Unemployment Rate: {metrics['unemployment_rate']:.2f}%
- Fed Funds Rate: {metrics['fed_funds_rate']:.2f}%
- Industrial Production YoY: {metrics['industrial_production_yoy']:.2f}%

## Supply Chain Highlights
Top chokepoints:

{supply_df.to_markdown(index=False)}

Artifacts:
- Supply metrics CSV: artifacts/supply_metrics.csv (downloadable within app)

## Valuation
- DCF intrinsic value / share: ${dcf_result['equity_value_per_share']:.2f}
- Enterprise value (model): {_format_dollar(dcf_result['enterprise_value'])}
- Equity value (model): {_format_dollar(dcf_result['equity_value'])}
- Peer set: {', '.join(peers)}

Applied DCF overrides:
{overrides_text}

Relative comps:

{comps_table.to_markdown(index=False)}

## Risk
- Historical VaR 95%: {historical['var_95']:.4f}
- Historical VaR 99%: {historical['var_99']:.4f}
- Variance-Covariance VaR 95%: {variance_covariance['var_95']:.4f}
- Variance-Covariance VaR 99%: {variance_covariance['var_99']:.4f}
- Stress shock applied: {stress['shock_pct']:.2%}
- Portfolio loss under stress: {stress['portfolio_loss']:.2%}

## Notes
- Live data attempts rely on yfinance and FRED; missing credentials trigger cached sample usage.
- Supply network derived from sample edges mimicking GPU supplier stack.
- Report generated by `sal_dashboard` Streamlit interface.
"""
    return report


def main() -> None:
    st.set_page_config(page_title="Strategic Alpha Dashboard", layout="wide")
    st.title("Strategic Alpha Dashboard")

    settings = get_settings()

    st.sidebar.header("Controls")
    ticker = st.sidebar.text_input("Ticker", value="NVDA").upper()

    default_start = date.today() - timedelta(days=365 * 2)
    default_end = date.today()
    date_range = st.sidebar.date_input(
        "Date Range",
        value=(default_start, default_end),
        help="Historical window for price, valuation, and risk analytics.",
    )
    if not isinstance(date_range, tuple) or len(date_range) != 2:
        st.sidebar.error("Please select a valid start and end date.")
        st.stop()
    start_date, end_date = date_range
    start_str, end_str = start_date.isoformat(), end_date.isoformat()

    default_peers = settings.risk_peer_tickers
    peer_selection = st.sidebar.multiselect(
        "Peer Set",
        options=sorted(set(default_peers + [ticker])),
        default=[peer for peer in default_peers if peer != ticker],
        help="Select peers for comps and risk benchmarking.",
    )
    if ticker not in peer_selection:
        peer_selection = [ticker] + peer_selection

    shock_pct = st.sidebar.slider(
        "Shock %",
        min_value=-30.0,
        max_value=-5.0,
        value=-10.0,
        step=0.5,
        help="Apply to foundry-exposed names in stress test.",
    )

    # Load backend analytics
    macro_result = macro.load_macro_snapshot(end=end_str, settings=settings)
    macro_df = macro.macro_dataframe(macro_result)

    supply_result = supply.load_supply_analysis(settings)
    supply_metrics_df = supply.supply_metrics(supply_result)
    chokepoints_df = supply.chokepoints_table(supply_result)

    price_series, base_inputs = valuation.base_dcf_inputs(ticker, start_str, end_str)
    valuation_result = valuation.load_valuation_result(
        ticker=ticker,
        start=start_str,
        end=end_str,
        peers=peer_selection,
        settings=settings,
    )
    comps_df = valuation_result.comps

    dcf_overrides = _dcf_override_inputs(base_inputs)
    overridden_inputs = valuation.override_dcf_inputs(base_inputs, dcf_overrides)
    dcf_result = valuation.run_dcf_model(overridden_inputs)

    risk_result = risk.load_risk_result(
        ticker=ticker,
        start=start_str,
        end=end_str,
        shock_pct=shock_pct / 100,
        settings=settings,
    )
    risk_details = risk.risk_summary(risk_result)
    portfolio_returns = risk.portfolio_returns(risk_result)

    info = _fetch_quote_info(ticker)
    kpi_labels = ["Market Cap", "Enterprise Value", "P/E", "EBITDA Margin"]
    kpi_values = [
        _format_dollar(info.get("marketCap")),
        _format_dollar(info.get("enterpriseValue") or info.get("marketCap")),
        f"{info.get('trailingPE', float('nan')):.2f}" if info.get("trailingPE") else "NA",
        f"{info.get('ebitdaMargins', float('nan'))*100:.2f}%" if info.get("ebitdaMargins") else "NA",
    ]

    overview_tab, macro_tab, supply_tab, valuation_tab, risk_tab, report_tab = st.tabs(
        ["Overview", "Macro Context", "Supply Map", "Valuation", "Risk", "Report"]
    )

    with overview_tab:
        render_kpi_cards(kpi_labels, kpi_values)
        st.subheader("Price Performance")
        st.plotly_chart(price_chart(_last_12m(price_series)), use_container_width=True)

    with macro_tab:
        st.plotly_chart(macro_chart(macro_df), use_container_width=True)
        st.info(macro.macro_commentary(macro_result.metrics))

    with supply_tab:
        st.plotly_chart(
            supply.supply_graph_figure(supply_result), use_container_width=True
        )
        st.dataframe(format_chokepoints(chokepoints_df), use_container_width=True)
        st.download_button(
            label="Download Supply Metrics CSV",
            data=supply.metrics_csv_bytes(supply_metrics_df),
            file_name="supply_metrics.csv",
            mime="text/csv",
        )

    with valuation_tab:
        st.subheader("Discounted Cash Flow")
        cols = st.columns(3)
        cols[0].metric("PV of Cash Flows", _format_dollar(sum(dcf_result["present_value"].values())))
        cols[1].metric(
            "Terminal Value",
            _format_dollar(dcf_result["terminal_value"]),
        )
        cols[2].metric(
            "Equity Value / Share",
            f"${dcf_result['equity_value_per_share']:.2f}",
        )
        st.plotly_chart(dcf_heatmap(dcf_result["sensitivity"]), use_container_width=True)

        st.subheader("Relative Comps")
        st.dataframe(format_comps(comps_df), use_container_width=True)
        percentiles = valuation.peer_percentiles(comps_df, ticker)
        st.caption(
            "Percentile positioning vs. peers "
            f"(P/E: {percentiles['pe']!s}, EV/EBITDA: {percentiles['ev_ebitda']!s}, P/S: {percentiles['ps']!s})"
        )

    with risk_tab:
        st.subheader("Value at Risk")
        hist = risk_details["historical"]
        varcov = risk_details["variance_covariance"]
        stress_info = risk_details["stress"]

        st.write(
            pd.DataFrame(
                {
                    "Method": ["Historical", "Historical", "Variance-Covariance", "Variance-Covariance"],
                    "Confidence": ["95%", "99%", "95%", "99%"],
                    "VaR": [
                        hist["var_95"],
                        hist["var_99"],
                        varcov["var_95"],
                        varcov["var_99"],
                    ],
                }
            )
        )
        st.write(
            f"Stress shock {stress_info['shock_pct']:.2%} → portfolio impact {stress_info['portfolio_loss']:.2%}"
        )
        st.plotly_chart(risk_histogram(portfolio_returns), use_container_width=True)

    with report_tab:
        st.subheader("Generate Markdown Report")
        formatted_chokepoints = format_chokepoints(chokepoints_df)[
            ["node", "country", "betweenness"]
        ]
        formatted_comps = format_comps(comps_df)[
            ["ticker", "price", "pe", "ev_ebitda", "ps"]
        ]
        report_text = _report_content(
            ticker=ticker,
            macro_result=macro_result,
            supply_df=formatted_chokepoints,
            dcf_result=dcf_result,
            comps_table=formatted_comps,
            risk_summary=risk_details,
            dcf_overrides=dcf_overrides,
            peers=[p for p in peer_selection if p != ticker],
        )
        if st.button("Save Report"):
            report_path = ROOT_DIR / "reports" / f"{ticker.upper()}_dashboard_memo.md"
            report_path.write_text(report_text, encoding="utf-8")
            st.success(f"Report written to {report_path}")
        st.download_button(
            "Download Markdown",
            data=report_text.encode("utf-8"),
            file_name=f"{ticker.upper()}_dashboard_memo.md",
            mime="text/markdown",
        )


if __name__ == "__main__":
    main()
